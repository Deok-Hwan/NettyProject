package netty.note;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.handler.codec.base64.Base64Encoder;
import io.netty.util.concurrent.SingleThreadEventExecutor;

/**
 * 
 * @author 박덕환
 * 데이터의 이동의 방향성
 * 
 * 네티는 이벤트를 인바운드 이벤트와 아웃바운드 이벤트로 구분한 추상화 모델을 제공한다.
 * 즉, 네트워크 프로그램 개발자가 신경 써야 하는 이벤트를 논리적으로 구분하여 고수준의 추상화 모델을 제공한다. 
 * 예를 들어 서버 개발자는 클라이언트로 부터 데이터가 수신 될 때 발생하는 이벤트에 관심이 있다면 인바운드 이벤트 중 하나인
 * 데이터 수신 이벤트 메서드에서 데이터를 가공하는 코드를 작성하면 된다.
 * 
 * 이로써 서버가 수행할 동작에 대한 코드 작성이 완료 된다.
 * 
 * 네티는 이와 같이 적절한 추상화 모델을 제공하여 네티 사용자로 하여금 간단한 코드 작성만으로 안정적인 어플리 케이션으 빠르게
 * 개발할 수 있다.
 * 
 * 네티는 네트워크 송수신을 추상화하기 위하여 이벤트 모델을 정의 했다. 
 * 즉 데이터 송신을 아웃바운드 이벤트, 데이터 수신을 인바운드 이벤트로 정의하고 있다.
 * 인바운드 이벤트와 아웃바운드 이벤트는 모두 프로그램을 기준으로 정의된다. 
 *
 * 인바운드와 아웃바운드의 구분은 애플리케이션의 소켓 채널을 기준으로 정의된다.
 */
public class NettyNote {
	
	/*
	 * 
	 */
	public void NettySyncronize(){}
	
	/*
	 * 소켓의 동작 방식은 블로킹 모드와 논블로킹 모드로 나뉜다.
	 * 블로킹은 요청한 작업이 성공하거나, 에러가 발생하기 전까지는 응답을 돌려주지 않는 것을 말하며,
	 * 논 블로킹은 요청한 작업의 성공 여부와 상관없이 바로 결과를 돌려 주는것을 말한다.
	 *  이 떄 요청의 응답값에 의해서 에러나 성공 여부를 판단한다.
	 *  
	 *  자바는 두 가지 소켓을 구분하기 위해서 별도의 클래스를 사용한다.
	 *  블로킹 소켓은 ServerSocket, Socket 클래스, 논블로킹 소켓은 ServerSocketChannel, SocketChannel 클래스를
	 *  사용한다.
	 */
	/*
	 * 블로킹 방식의 서버 소켓의 accept 메서드가 병목 지점이다. 특히 ServerSockt 클래스가 제공하는 accept 메서드는 단위 시간에 하나의 연결
	 * 만을 처리하는 블로킹 모드로 동작하기 때문에 여러 클라이언트가 동시에 접속 요청을 하는 상황에서 대기 시간이 길어진다는
	 * 단점이 있다. 또한 접속할 클라이언트 수가 저해져 있지 않은 상황에서도 문제가 있을 수 있다.
	 * 서버에 접속하는 클라이언트 수가 증가하면 애플리케이션의 서버의 스레드 수가 증가하게 되는데
	 * 이 때 자바의 힙 메모리 부족으로 인한 OOM(Out of Memory) 오류가 발생 할 수 있다.
	 * 위와 같은 서비스 불가 상황이 발생하지 않도록 하려면 서버에서 생성되는 스레드 수를 제한하는 방법인
	 * 스레드 풀링을 사용하기도 한다. 
	 * 
	 * 동시 접속 수를 늘리기 위해서 스레드 풀의 크기를 자바 힙이 허용하는 최대 한도에 도달할 때 까지 늘리는 것이 합당한지 두 가지 관점에서
	 * 생각해 볼 필요가 있다.
	 * 
	 * 첫 번째는 자바의 가비지 컬렉션.
	 * 힙 크기가 크면 클수록 가비지 컬렉션에 드는 시간이 길어진다. 힙 크기와 생성 가능한 스레드 수는 비례한다.
	 * 힙에 할당된 메모리가 클수록 가비지 컬렉션이 수행되는 횟수는 줄어들지만 수행시간은 상대적으로 길어진다.
	 * 
	 * 두 번째는 운영체제에서 사용되는 컨텍스트 스위칭에 관한 고찰이다. 컨텍스트 스위칭이란 한 프로세스에서 수행되는
	 * 스레드들이 CPU 점유를 위해서 자신의 상태를 변경하는 작업이다. 이 때 수많은 스레드가 CPU 자원을 휙득하기 위해 경쟁하면서
	 * CPU 자원을 소모하기 때문에 실제로 작업에 사용할 CPU 자원이 적어지게 된다.
	 * 
	 * 블로킹 소켓의 동작 방식으로 인하여 블로킹 소켓을 사용한 서버는 충분히 많은 동시접속 사용자를 수용하지 못한다.
	 * 이런 단점을 개선한 방식이 논블로킹 소켓 방식이다.
	 */
	public void NettyBlocking(){}
	
	/*
	 * NonBlockingServer 참고
	 */
	public void NettyNonBlocking(){}
	
	/*
	 * 이벤트 프로그래밍에서 중요한 부분은 추상화 수준이다. 
	 * 추상화 수준이란 이벤트를 나눌 때 작은 단위로 나누었는지, 큰 단위로 나누었는지의 정도를 말한다. 
	 * 이벤트 추상화가 너무 고수준이면 세부적인 제어가 힘들어진다. 반대로,
	 * 매우 저수준이면 한 동적에서 너무 많은 이벤트가 발생하여 이벤트 성능에 악영향을 미치게 된다.
	 * 
	 * 서버에서 사용하는 이벤트 기반 프레임워크의 적절한 추상화 단위는 매우 중요하다.
	 * 
	 * ** 이벤트 기반 네트워크 프로그래밍 **
	 * 이벤트 기반 네트워크 프로그래밍을 제공하려면 먼저 이벤트를 발생하는 객체를 정의해야 한다.
	 * 이벤트가 발생할 주체를 정의하고 그 주체에서 발생될 이벤트 종류를 정의해야 한다.
	 * 
	 * 네티는 데이터의 읽기 쓰기를 위한 이벤트 핸들러를 지원하는데, 1장에서 살펴본 ChannelInboundHandlerAdapter가 이에 해당된다.
	 */
	public void EventPrograming(){}
	
	/*
	 * 부트스트랩은 네티로 작성한 네트워크 어플리케이션이 시작할 때 가장 처음 수행되는 부분으로서 어플리케이션이 수행할 동작과
	 * 각종 설정을 지정하며 네티 어플리케이션의 기본이 된다.
	 * 
	 * 부트스트랩의 설정은 크게 이벤트 루프, 채널의 전송 모드, 채널 파이프라인 으로 나뉜다.
	 * 이벤트 루프는 소켓 채널에서 발생한 이벤트를 처리하는 스레드 모델에 대한 구현이 담겨 있다.
	 * 부트스트랩에 설정한 소켓의 모드에 따라 사용되는 이벤트 루프의 구현체가 달라지기도 하는데 사용할 
	 * 소켓 채널의 모드에 따라서 블로킹, 논블로킹 그리고 epoll로 설정할 수 있다.
	 * epoll은 입출력 다중화 기법으로써 현재 까지 알려진 입출력 방식 중에 가장 빠르다.
	 * 하지만 리눅스에서만 동작하며, 커널 버전 2.6부터 사용할 수 있다.
	 * 
	 * 채널 파이프라인은 소켓 채널로 수신된 데이터를 처리할 데이터 핸들러들을 지정한다.
	 * 채널 파이프라인은 연결된 채널에서 사용할 데이터 핸들러에 대한 내용을 포함한다.
	 * 이벤트 루프 : 스레드 모델
	 * 채널의 전송 모드 : 동기 / 비동기
	 * 채널 파이프라인 : 데이터 핸들러 
	 */
	public void NettyBootStrap(){}
	
	/*
	 * 부트스트랩은 네티로 작성한 네트워크 애플리케이션의 동작 방식과 환경을 설정하는 도우미 클래스이다.
	 * 부트스트랩의 구조 
	 * ** 전송 계층 (소켓 모드 및 I/O 종류)
	 * ** 이벤트 루프(단일 스레드, 다중 스레드)
	 * ** 채널 파이프라인 설정
	 * ** 소켓 주소와 포트
	 * ** 소켓 옵션
	 * 
	 * 실제로 부트스트랩은 네트워크 애플리케이션 설정에 필요한 모든 내용을 담고 있다.
	 * 통상적으로 네트워크 어플리케이션은 서비스를 제공할 네트워크 포트, 
	 * 네트워크 전송에 사용할 소켓 모드와 소켓 옵션, 소켓의 데이터를 처리하는 스레드
	 * 그리고 어플리케이션에서 사용할 프로토콜로 구성된다.
	 * 대표적은 웹 서버인 아파치 톰캣은
	 * XML을 사용하여 톰켓 커넥터가 사용할 입출력 모드와 스레드 수, 그리고 tcp 서비스 포트를 설정할 수 있다.
	 * 또한 웹 서버이므로 HTTP 프로토콜을 사용하며 웹 서비스 관리자를 위한 계정을 설정한다. 웹 서버에 특화된 내용이 추가 되어 
	 * 있을 뿐, 네티의 부트스트랩 설정 내용과 대부분 동일하다.
	 * 프로토콜은 채널 파이프라인에 등록되는 인코더와 디코더에서 처리 된다.
	 * 
	 * 네티 부트 스트랩은 서버 애플리케이션을 위한 ServerBootStrap 클래스와 클라이언트 애플리케이션을 위한
	 * BootStrap 클래스로 나뉜다. 여기서 말하는 서버 애플리케이션과 클라이언트 애플리케이션의 구분은 소켓 연결을 요청하느냐
	 * 아니면 대기하느냐에 따른 구분이다.
	 * 
	 * 상대방 소켓으로 연결 요청을 시도하는 쪽이 클라이언트이다.
	 * 
	 * 부트 스트랩은 빌더 패턴을 사용하여 구현되어 있다.
	 * 빌드 패턴 : 메서드의 호출 결과를 자신의 객체 참조를 돌려주는 프로그래밍을 구현하는 패턴의 일종.
	 * 
	 * 블로킹 소켓을 지원하는 서버 애플리케이션을 논블로킹 모드로 변환하는데 아주 많은 코드로 변경해야 하지만 네티는
	 * 부트스트랩의 설정을 통해서 데이터 처리 코드를 변경하지 않고 BolockingServer 또는
	 * NonBlockingServer와 동일한 동작을 하는 애플리케이션을 작성할 수 있다.
	 * 
	 */
	public void NettyBootStrapInit(){}
	
	/*
	 * group - 이벤트 루프 설정
	 * 먼저 데이터 송수신 처리를 위한 이벤트 루프를 설정하는 group 메서드를 살펴보자. 
	 * group 메서드는 AbstractBootStrap 클래스의 맴버 메서드로 정의되어 있다.
	 * 
	 * 
	 * channel - 소켓 입출력 모드 설정
	 * 메서드는 AbstractBootstrap 추상 클래스의 구현체인 ServerBootstrap과 Bootstrap 클래스에
	 * 모두 존재하는 API이며 부트스트랩 클래스를 통해서 생성된 채널의 입출력 모드를 설정할 수 있다.
	 * 
	 * channelFactory - 소켓 입출력 모드 설정
	 * channelFactory 메서드는 channel 메서드와 동일하게 소켓의 입출력 모드를 설정하는 API다.
	 * channelFactory 인터페이스를 상속 받은 클래스를 설정할 수 있으며 channel 메서드와 동일한 기능을 수행한다.
	 * 
	 * handler - 서버 소켓 채널의 이벤트 핸들러 설정
	 * 서버 소켓 채널의 이벤트를 처리할 핸들러 설정 API인 handler 메서드를 살펴보자. 이 메서드를 
	 * 통해서 등록되는 이벤트 핸들러는 서버 소켓 채널에서 발생하는 이벤트를 수신하여 처리한다.
	 * 
	 * childHandler -  소켓 채널의 데이터 가공 핸들러 설정
	 * 클라이언트 소켓 채널로 송수신되는 데이터를 가공하는 핸들러 설정 API이다.
	 * 
	 * option - 서버 소캣 채널의 소켓 옵션 설정
	 * 소켓 옵션이란 소켓의 동작 방식을 지정하는 것을 말한다.
	 * SO_SNDBUF 옵션은 소켓이 사용할 송신 버퍼의 크기를 지정한다.
	 * 소켓 옵션은 커널에서 사용되는 값으 ㄹ변경한다는 의미다.
	 * 
	 * childOption - 소켓 채널의 소켓 옵션 설정
	 * childOption 메서드는 앞에서 살펴본 option 메서드와 같이 소켓 채널에 옵션을 설정한다.
	 * option 메서드는 서버 소켓 채널의 옵션을 설정하는데 반해 childOption 메서드는 서버에 접속한 클라이언트
	 * 소켓 채널에 대한 옵션을 설정하는데 사용한다.
	 * 
	 */
	public void ServerBootStrapAPI(){}
	
	/*
	 * 
	 */
	public void BootStrapAPI(){}
	
	/*
	 * 채널 파이프라인은 채널에서 발생한 이벤트가 이동하는 통로다. 이 통로를 통해서 이동하는 이벤트를 처리하는 클래스를
	 * 이벤트 핸들러라고 하며 이벤트 핸드러를 상속 받아서 구현한 구현체들을 코덱이라고 한다.
	 * 
	 * 채널 파이프라인은 네티의 채널과 이벤트 핸들러 사이에서 연결 통로 역할을 수행한다.
	 * 
	 * **채널 인바운드 이벤트
	 * 네티는 소켓 채널에서 발생하는 이벤트를 인바운드 이벤트와 아웃바운드 이벤트로 추상화한다.
	 * 인바운드 이벤트는 소켓 채널에서 발생한 이벤트 중에서 연결 상대방이 어떤 동작을 취했을 때 동작한다.
	 * 예를 들면 채널 활성화, 데이터 수신 등의 이벤트가 이에 해당한다.
	 * 
	 * -- 인바운드 이벤트 발생 순서
	 * 1. 이벤트 루프에 채널 등록(ChannelRegisted)
	 * 2. 채널 활성화 (channelActive)
	 * 3. 데이터 수신 (channelRead)
	 * 4. 데이터 수신 완료 (channelReadComplete)
	 * 5. 채널 비활성화 (channelInactive)
	 * 6. 이벤트 루프에서 채널 제거 (channelUnregisted)
	 * 
	 * *channelRegisted 이벤트
	 * channelRegisted 이벤트는 채널이 이벤트 루프에 등록되었을 때 발생한다. 이벤트 루프는 네티가 이벤트를 실행하는 스레드로써 부트 스트랩에
	 * 설정한 이벤트 루프다. channelRegisted 이벤트는 클라이언트와 서버에서 발생 위치가 조금 다르다. 
	 * 서버 측은 처음 서버 소켓 채널을 생성할 때와 새로운 클라이언트가 서버에 접속하여 클라이언트 소켓 채널이 생성 될 때 channelRegisted 이벤트가
	 * 발생한다. 
	 * 
	 * *channelActive 이벤트
	 * channelActive 이벤트는 channelRegisted 이벤트 이후에 발생한다. 
	 * 이는 채널이 생성되고 이벤트 루프에 등록된 이후에 네티 API를 사용하여 채널 입출력을 수행할 상태가 되었음을 알려주는 이벤트이다.
	 * 
	 * *channelRead 이벤트
	 * channelRead 이벤트는 네티로 작성된 애플리케이션에서 빈도 높게 생성되는 이벤트로서 데이터가  수신되었음을 알려 준다.
	 * 수신된 데이터는 네티의 ByteBuf 객체에 저장되어 있으며 이벤트 메서드의 두 번째 인자가 msg를 통해서 접근할 수 있다.
	 * 
	 * * channelReadComplete 이벤트
	 * channelReadComplete 이벤트는 데이터 수신이 완료 되었음을 알려 준다.
	 * channelRead이벤트는 채널에 데이터가 있을 때 발생 하고 채널의 데이터를 다 읽어서 더 이상 데이터가 없을 때 channelReadComplete 이벤트가
	 * 발생한다. 
	 * 
	 * ** 아웃바운드 이벤트
	 * - bind 이벤트
	 * bind 이벤트는 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생한다.
	 * 
	 * - Connect 이벤트
	 * connect 이벤트는 클라이언트 소켓 채널이 서버에 연결되었을 때 발생한다. connect 이벤트에서는 원격지의 SocketAddress 정보와 로컬 SocketAddress
	 * 정보가 인수로 입력된다. 만약 원격지의 연결을 생성할 때 로컬 SocketAddress 정보를 입력하지 않았다면 이 이벤트에서 수신한 로컬 SocketAdress는 null 이다.
	 * 
	 * - disconnect 이벤트
	 * disconnect 이벤트는 클라이언트 소켓 채널의 연결이 끊어졌을 때 발생한다. 
	 * 
	 * - close 이벤트
	 * close 이벤트는 클라이언트 소켓 채널의 연결이 닫혔을 때 발생한다. 
	 * 
	 * - write 이벤트
	 * write 이벤트는 소켓 채널에 데이터가 기록되었을 때 발생한다.
	 * 
	 * - flush 이벤트 
	 * flush 이벤트는 소켓 채널에 대한 flush 메서드가 호출되었을 때 발생한다.
	 */
	public void ChannelPipeLine (){}
	
	/*
	 * ** 코덱의 구조
	 * 인바운드와 아웃바운드에 해당하는 이벤트는 ChannelOutboundHandler와 ChannelInboundHandler 인터페이스로 각각
	 * 인코더와 디코더라고 부른다.
	 * 
	 * 데이터를 전송할 때는 인코더를 사용하여 패킷으로 변환하고 데이터를 수신할 때는 디코더를 사용하여 패킷을 데이터로 변환한다.
	 * 결국 코덱은  = 프로토콜(?)
	 * 
	 * 
	 */
	public void CodecStructure (){
//		Base64Encoder
	}
	
	/*
	 *** 이벤트 루프
	 * 이벤트를 처리하는 방법은 크게 2가지 이다.
	 * 첫 번째는 이벤트 리스너와 이벤트 처리 스레드에 기반한 방법이다.
	 * 이벤트를 처리하는 로직을 가진 이벤트 메서드를 대상 객체의 이벤트 리스너에 등록하고 객체에 이벤트가 발생했을 때
	 * 이벤트 처리 스레드에서 등록된 메서드를 수행한다.
	 * 이 때 이벤트 메서드를 수해하는 스레드는 대부분 단일 스레드로 구현한다.
	 * 
	 * 두 번째는 이벤트 큐에 이벤트를 등록하고 이벤트 루프가 이벤트 큐에 접근하여 처리하는 방법이다.
	 * 첫 번째 방법에 비해 프레임워크의 구현이 복잡하지만 프레임워크의 사용자 입장에서는 더 간단하게 사용할 수 있다.
	 * 
	 * 이벤트 루프가 다중 스레드 일 때 이벤트 큐는 여러 개의 스레드에서 공유 되며 가장 먼저 이벤트 큐에 접근한 스레드가 
	 * 첫 번째 이벤트를 가져와서 이벤트를 수행한다. 이 때 이벤트 큐에 입력된 이벤트를 처리하고자 이벤트 루프 스레드를 사용한다.
	 * 
	 */
	public void EventLoop (){
	}
	
	/*
	 * 단일 스레드 이벤트 루프는 이벤트를 처리하는 스레드가 하나인 상태를 말한다. 그러므로 이벤트 루프의 구현이
	 * 단순하고 예측 가능한 동작을 보장한다. 또한 하나의 스레드가 이벤트 큐에 입려된
	 * 이벤트를 처리하므로 이벤트가 발생한 순서대로 수행할 수 있다.
	 * 단점으로는 다중 코어 CPU를 효율적으로 사용하지 못하며 이벤트 메서드에 처리 시간이 오래 걸리는 작업이 
	 * 섞여 있을 때 나중에 들어온 이벤트는 처리까지 더 오랜 시간이 걸린다.
	 * 
	 * 단일 스레드는 이벤트 루프의 단점으 극복하기 위해 다중 스레드 이벤트 루프를 사용한다.
	 * 
	 */
	public void SingleThread_MultiThread_EventLoop (){
//		SingleThreadEventExecutor
	}
	
	/*
	 * 자바 버퍼는 바이트 데이터를 저장하는 저장소로써 저장된 데이터를 읽고 쓰는 메서드를 제공한다.
	 * 또한 저장되는 데이터 형에 따라서 읽고 쓰는 데이터의 크기가 달라지는데 이를 Buffer 추상 클래스를
	 * 사용하여 처리한다. 
	 * 
	 * ** 자바 바이트 버퍼 생성
	 * 통상적으로 자바에서 객체를 생성할 때는 생성자를 이용한다. 하지만 자바의 바이트 버퍼는 데이터형에 
	 * 따른 추상 클래스의 팩토리 메서드를 통해서 생성한다. 바이트 버퍼를 생성하는 메서드는 모두 세 가지가
	 * 존재하며 각 메서드는 다음과 같다.
	 * 
	 * allocate : JVM의 힙 영역에 바이트 버퍼 생성
	 * allocateDirect : JVM의 힙 영역이 아닌 운영체제의 커널 영역에 바이트 버퍼를 생성한다.
	 * wrap : 입려된 바이트 배열을 사용하여 바이트 버퍼를 생성한다. 
	 * 
	 */
	public void ByteBuffer(){
		
	}
	
}
