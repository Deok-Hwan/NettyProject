package netty.note;

import io.netty.bootstrap.ServerBootstrap;

/**
 * 
 * @author 박덕환
 * 데이터의 이동의 방향성
 * 
 * 네티는 이벤트를 인바운드 이벤트와 아웃바운드 이벤트로 구분한 추상화 모델을 제공한다.
 * 즉, 네트워크 프로그램 개발자가 신경 써야 하는 이벤트를 논리적으로 구분하여 고수준의 추상화 모델을 제공한다. 
 * 예를 들어 서버 개발자는 클라이언트로 부터 데이터가 수신 될 때 발생하는 이벤트에 관심이 있다면 인바운드 이벤트 중 하나인
 * 데이터 수신 이벤트 메서드에서 데이터를 가공하는 코드를 작성하면 된다.
 * 
 * 이로써 서버가 수행할 동작에 대한 코드 작성이 완료 된다.
 * 
 * 네티는 이와 같이 적절한 추상화 모델을 제공하여 네티 사용자로 하여금 간단한 코드 작성만으로 안정적인 어플리 케이션으 빠르게
 * 개발할 수 있다.
 * 
 * 네티는 네트워크 송수신을 추상화하기 위하여 이벤트 모델을 정의 했다. 
 * 즉 데이터 송신을 아웃바운드 이벤트, 데이터 수신을 인바운드 이벤트로 정의하고 있다.
 * 인바운드 이벤트와 아웃바운드 이벤트는 모두 프로그램을 기준으로 정의된다. 
 *
 * 인바운드와 아웃바운드의 구분은 애플리케이션의 소켓 채널을 기준으로 정의된다.
 */
public class NettyNote {
	
	/*
	 * 
	 */
	public void NettySyncronize(){}
	
	/*
	 * 소켓의 동작 방식은 블로킹 모드와 논블로킹 모드로 나뉜다.
	 * 블로킹은 요청한 작업이 성공하거나, 에러가 발생하기 전까지는 응답을 돌려주지 않는 것을 말하며,
	 * 논 블로킹은 요청한 작업의 성공 여부와 상관없이 바로 결과를 돌려 주는것을 말한다.
	 *  이 떄 요청의 응답값에 의해서 에러나 성공 여부를 판단한다.
	 *  
	 *  자바는 두 가지 소켓을 구분하기 위해서 별도의 클래스를 사용한다.
	 *  블로킹 소켓은 ServerSocket, Socket 클래스, 논블로킹 소켓은 ServerSocketChannel, SocketChannel 클래스를
	 *  사용한다.
	 */
	/*
	 * 블로킹 방식의 서버 소켓의 accept 메서드가 병목 지점이다. 특히 ServerSockt 클래스가 제공하는 accept 메서드는 단위 시간에 하나의 연결
	 * 만을 처리하는 블로킹 모드로 동작하기 때문에 여러 클라이언트가 동시에 접속 요청을 하는 상황에서 대기 시간이 길어진다는
	 * 단점이 있다. 또한 접속할 클라이언트 수가 저해져 있지 않은 상황에서도 문제가 있을 수 있다.
	 * 서버에 접속하는 클라이언트 수가 증가하면 애플리케이션의 서버의 스레드 수가 증가하게 되는데
	 * 이 때 자바의 힙 메모리 부족으로 인한 OOM(Out of Memory) 오류가 발생 할 수 있다.
	 * 위와 같은 서비스 불가 상황이 발생하지 않도록 하려면 서버에서 생성되는 스레드 수를 제한하는 방법인
	 * 스레드 풀링을 사용하기도 한다. 
	 * 
	 * 동시 접속 수를 늘리기 위해서 스레드 풀의 크기를 자바 힙이 허용하는 최대 한도에 도달할 때 까지 늘리는 것이 합당한지 두 가지 관점에서
	 * 생각해 볼 필요가 있다.
	 * 
	 * 첫 번째는 자바의 가비지 컬렉션.
	 * 힙 크기가 크면 클수록 가비지 컬렉션에 드는 시간이 길어진다. 힙 크기와 생성 가능한 스레드 수는 비례한다.
	 * 힙에 할당된 메모리가 클수록 가비지 컬렉션이 수행되는 횟수는 줄어들지만 수행시간은 상대적으로 길어진다.
	 * 
	 * 두 번째는 운영체제에서 사용되는 컨텍스트 스위칭에 관한 고찰이다. 컨텍스트 스위칭이란 한 프로세스에서 수행되는
	 * 스레드들이 CPU 점유를 위해서 자신의 상태를 변경하는 작업이다. 이 때 수많은 스레드가 CPU 자원을 휙득하기 위해 경쟁하면서
	 * CPU 자원을 소모하기 때문에 실제로 작업에 사용할 CPU 자원이 적어지게 된다.
	 * 
	 * 블로킹 소켓의 동작 방식으로 인하여 블로킹 소켓을 사용한 서버는 충분히 많은 동시접속 사용자를 수용하지 못한다.
	 * 이런 단점을 개선한 방식이 논블로킹 소켓 방식이다.
	 */
	public void NettyBlocking(){}
	
	/*
	 * NonBlockingServer 참고
	 */
	public void NettyNonBlocking(){}
	
	/*
	 * 이벤트 프로그래밍에서 중요한 부분은 추상화 수준이다. 
	 * 추상화 수준이란 이벤트를 나눌 때 작은 단위로 나누었는지, 큰 단위로 나누었는지의 정도를 말한다. 
	 * 이벤트 추상화가 너무 고수준이면 세부적인 제어가 힘들어진다. 반대로,
	 * 매우 저수준이면 한 동적에서 너무 많은 이벤트가 발생하여 이벤트 성능에 악영향을 미치게 된다.
	 * 
	 * 서버에서 사용하는 이벤트 기반 프레임워크의 적절한 추상화 단위는 매우 중요하다.
	 * 
	 * ** 이벤트 기반 네트워크 프로그래밍 **
	 * 이벤트 기반 네트워크 프로그래밍을 제공하려면 먼저 이벤트를 발생하는 객체를 정의해야 한다.
	 * 이벤트가 발생할 주체를 정의하고 그 주체에서 발생될 이벤트 종류를 정의해야 한다.
	 * 
	 * 네티는 데이터의 읽기 쓰기를 위한 이벤트 핸들러를 지원하는데, 1장에서 살펴본 ChannelInboundHandlerAdapter가 이에 해당된다.
	 */
	public void EventPrograming(){}
	
	/*
	 * 부트스트랩은 네티로 작성한 네트워크 어플리케이션이 시작할 때 가장 처음 수행되는 부분으로서 어플리케이션이 수행할 동작과
	 * 각종 설정을 지정하며 네티 어플리케이션의 기본이 된다.
	 * 
	 * 부트스트랩의 설정은 크게 이벤트 루프, 채널의 전송 모드, 채널 파이프라인 으로 나뉜다.
	 * 이벤트 루프는 소켓 채널에서 발생한 이벤트를 처리하는 스레드 모델에 대한 구현이 담겨 있다.
	 * 부트스트랩에 설정한 소켓의 모드에 따라 사용되는 이벤트 루프의 구현체가 달라지기도 하는데 사용할 
	 * 소켓 채널의 모드에 따라서 블로킹, 논블로킹 그리고 epoll로 설정할 수 있다.
	 * epoll은 입출력 다중화 기법으로써 현재 까지 알려진 입출력 방식 중에 가장 빠르다.
	 * 하지만 리눅스에서만 동작하며, 커널 버전 2.6부터 사용할 수 있다.
	 * 
	 * 채널 파이프라인은 소켓 채널로 수신된 데이터를 처리할 데이터 핸들러들을 지정한다.
	 * 채널 파이프라인은 연결된 채널에서 사용할 데이터 핸들러에 대한 내용을 포함한다.
	 * 이벤트 루프 : 스레드 모델
	 * 채널의 전송 모드 : 동기 / 비동기
	 * 채널 파이프라인 : 데이터 핸들러 
	 */
	public void NettyBootStrap(){}
	
	/*
	 * 부트스트랩은 네티로 작성한 네트워크 애플리케이션의 동작 방식과 환경을 설정하는 도우미 클래스이다.
	 * 부트스트랩의 구조 
	 * ** 전송 계층 (소켓 모드 및 I/O 종류)
	 * ** 이벤트 루프(단일 스레드, 다중 스레드)
	 * ** 채널 파이프라인 설정
	 * ** 소켓 주소와 포트
	 * ** 소켓 옵션
	 * 
	 * 통상적으로 네트워크 어플리케이션은 서비스를 제공할 네트워크 포트, 
	 * 네트워크 전송에 사용할 소켓 모드와 소켓 옵션, 소켓의 데이터를 처리하는 스레드
	 * 그리고 어플리케이션에서 사용할 프로토콜로 구성된다.
	 * 대표적은 웹 서버인 아파치 톰캣은
	 * XML을 사용하여 톰켓 커넥터가 사용할 입출력 모드와 스레드 수, 그리고 tcp 서비스 포트를 설정할 수 있다.
	 * 또한 웹 서버이므로 HTTP 프로토콜을 사용하며 웹 서비스 관리자를 위한 계정을 설정한다. 웹 서버에 특화된 내용이 추가 되어 
	 * 있을 뿐, 네티의 부트스트랩 설정 내용과 대부분 동일하다.
	 * 프로토콜은 채널 파이프라인에 등록되는 인코더와 디코더에서 처리 된다.
	 * 
	 * 네티 부트 스트랩은 서버 애플리케이션을 위한 ServerBootStrap 클래스와 클라이언트 애플리케이션을 위한
	 * BootStrap 클래스로 나뉜다. 여기서 말하는 서버 애플리케이션과 클라이언트 애플리케이션의 구분은 소켓 연결을 요청하느냐
	 * 아니면 대기하느냐에 따른 구분이다.
	 * 
	 * 상대방 소켓으로 연결 요청을 시도하는 쪽이 클라이언트이다.
	 * 
	 * 부트 스트랩은 빌더 패턴을 사용하여 구현되어 있다.
	 * 빌드 패턴 : 메서드의 호출 결과를 자신의 객체 참조를 돌려주는 프로그래밍을 구현하는 패턴의 일종.
	 * 
	 * 블로킹 소켓을 지원하는 서버 애플리케이션을 논블로킹 모드로 변환하는데 아주 많은 코드로 변경해야 하지만 네티는
	 * 부트스트랩의 설정을 통해서 데이터 처리 코드를 변경하지 않고 BolockingServer 또는
	 * NonBlockingServer와 동일한 동작을 하는 애플리케이션을 작성할 수 있다.
	 * 
	 */
	public void NettyBootStrapInit(){}
	
	/*
	 * group - 이벤트 루프 설정
	 * 먼저 데이터 송수신 처리를 위한 이벤트 루프를 설정하는 group 메서드를 살펴보자. 
	 * group 메서드는 AbstractBootStrap 클래스의 맴버 메서드로 정의되어 있다.
	 * 
	 * 
	 * channel - 소켓 입출력 모드 설정
	 * 메서드는 AbstractBootstrap 추상 클래스의 구현체인 ServerBootstrap과 Bootstrap 클래스에
	 * 모두 존재하는 API이며 부트스트랩 클래스를 통해서 생성된 채널의 입출력 모드를 설정할 수 있다.
	 * 
	 * channelFactory - 소켓 입출력 모드 설정
	 * channelFactory 메서드는 channel 메서드와 동일하게 소켓의 입출력 모드를 설정하는 API다.
	 * channelFactory 인터페이스를 상속 받은 클래스를 설정할 수 있으며 channel 메서드와 동일한 기능을 수행한다.
	 * 
	 * handler - 서버 소켓 채널의 이벤트 핸들러 설정
	 * 서버 소켓 채널의 이벤트를 처리할 핸들러 설정 API인 handler 메서드를 살펴보자. 이 메서드를 
	 * 통해서 등록되는 이벤트 핸들러는 서버 소켓 채널에서 발생하는 이벤트를 수신하여 처리한다.
	 * 
	 * childHandler -  소켓 채널의 데이터 가공 핸들러 설정
	 * 클라이언트 소켓 채널로 송수신되는 데이터를 가공하는 핸들러 설정 API이다.
	 * 
	 * option - 서버 소캣 채널의 소켓 옵션 설정
	 * 소켓 옵션이란 소켓의 동작 방식을 지정하는 것을 말한다.
	 * SO_SNDBUF 옵션은 소켓이 사용할 송신 버퍼의 크기를 지정한다.
	 * 소켓 옵션은 커널에서 사용되는 값으 ㄹ변경한다는 의미다.
	 * 
	 * childOption - 소켓 채널의 소켓 옵션 설정
	 * childOption 메서드는 앞에서 살펴본 option 메서드와 같이 소켓 채널에 옵션을 설정한다.
	 * option 메서드는 서버 소켓 채널의 옵션을 설정하는데 반해 childOption 메서드는 서버에 접속한 클라이언트
	 * 소켓 채널에 대한 옵션을 설정하는데 사용한다.
	 * 
	 */
	public void ServerBootStrapAPI(){}
	
	/*
	 * 
	 */
	public void BootStrapAPI(){}
	
}
